"""
Django models related to the Tasking system
"""
from gettext import gettext as _
import logging

from django.db import models
from django.utils import timezone

from pulpcore.app.models import Model
from pulpcore.app.fields import JSONField
from pulpcore.common import TASK_FINAL_STATES
from pulpcore.exceptions import exception_to_dict


_logger = logging.getLogger(__name__)


class ReservedResource(Model):
    """
    Resources that have been reserved

    Fields:

        resource (models.TextField): The name of the resource reserved for the task.

    Relations:

        task (models.ForeignKey): The task associated with this reservation
        worker (models.ForeignKey): The worker associated with this reservation
    """
    resource = models.TextField()

    task = models.OneToOneField("Task")
    worker = models.ForeignKey("Worker", on_delete=models.CASCADE, related_name="reservations")


class WorkerManager(models.Manager):

    def get_unreserved_worker(self):
        """
        Randomly selects an unreserved :class:`~pulpcore.app.models.Worker`

        Return a random Worker instance that has no :class:`~pulpcore.app.models.ReservedResource`
        associated with it. If all workers have at least one ReservedResource relationship, a
        :class:`pulpcore.app.models.Worker.DoesNotExist` exception is raised.

        This method provides randomization for Worker selection to distribute load across workers.

        Returns:
            :class:`pulpcore.app.models.Worker`: A randomly-selected Worker instance that has zero
                :class:`~pulpcore.app.models.ReservedResource` entries associated with it.

        Raises:
            Worker.DoesNotExist: If all Workers have at least one ReservedResource entry.
        """
        workers_only_qs = self.filter(name__startswith='reserved', online=True)
        workers_only_qs_with_counts = workers_only_qs.annotate(models.Count('reservations'))
        try:
            return workers_only_qs_with_counts.filter(reservations__count=0).order_by('?')[0]
        except IndexError:
            raise self.model.DoesNotExist()


class Worker(Model):
    """
    Represents a worker

    Fields:

        name (models.TextField): The name of the worker, in the format "worker_type@hostname"
        last_heartbeat (models.DateTimeField): A timestamp of this worker's last heartbeat
        online (models.BooleanField): Whether is the worker online or not. Default is True.
    """
    objects = WorkerManager()

    name = models.TextField(db_index=True, unique=True)
    last_heartbeat = models.DateTimeField(auto_now=True)
    online = models.BooleanField(default=True)

    def save_heartbeat(self):
        """Save a worker heartbeat

        Update the last_heartbeat field to now and save it.

        Warnings:

            1) Only the last_heartbeat field will be saved. No other changes will be saved.

        Raises:
            ValueError: When the model instance has never been saved before. This method can
                only update an existing database record.
        """
        self.save(update_fields=['last_heartbeat'])


class TaskLock(Model):
    """
    Locking mechanism for services that utilize active/passive fail-over

    Fields:

        name (models.TextField): The name of the item that has the lock
        timestamp (models.DateTimeField): The time the lock was acquired
        lock (models.TextField): The name of the lock acquired

    """
    CELERY_BEAT = 'CeleryBeat'
    RESOURCE_MANAGER = 'ResourceManager'
    LOCK_STRINGS = (
        (CELERY_BEAT, 'Celery Beat Lock'),
        (RESOURCE_MANAGER, 'Resource Manager Lock')
    )

    name = models.TextField(db_index=True, unique=True)
    timestamp = models.DateTimeField(auto_now_add=True)
    lock = models.TextField(unique=True, null=False, choices=LOCK_STRINGS)


class Task(Model):
    """
    Represents a task

    Fields:

        group (models.UUIDField): The group this task belongs to
        state (models.TextField): The state of the task
        started_at (models.DateTimeField): The time the task started executing
        finished_at (models.DateTimeField): The time the task finished executing
        non_fatal_errors (pulpcore.app.fields.JSONField): Dictionary of non-fatal errors that
            occurred while task was running.
        error (pulpcore.app.fields.JSONField): Fatal errors generated by the task

    Relations:

        parent (models.ForeignKey): Task that spawned this task (if any)
        worker (models.ForeignKey): The worker that this task is in
    """

    WAITING = 'waiting'
    SKIPPED = 'skipped'
    RUNNING = 'running'
    COMPLETED = 'completed'
    FAILED = 'failed'
    CANCELED = 'canceled'
    STATES = (
        (WAITING, 'Waiting'),
        (SKIPPED, 'Skipped'),
        (RUNNING, 'Running'),
        (COMPLETED, 'Completed'),
        (FAILED, 'Failed'),
        (CANCELED, 'Canceled')
    )
    group = models.UUIDField(null=True)
    state = models.TextField(choices=STATES)

    started_at = models.DateTimeField(null=True)
    finished_at = models.DateTimeField(null=True)

    non_fatal_errors = JSONField(default=list)
    error = JSONField(null=True)

    parent = models.ForeignKey("Task", null=True, related_name="spawned_tasks")
    worker = models.ForeignKey("Worker", null=True, related_name="tasks")

    def set_running(self):
        """
        Set this Task to the running state, save it, and log output in warning cases.

        This updates the :attr:`started_at` and sets the :attr:`state` to :attr:`RUNNING`.
        """
        if self.state != self.WAITING:
            msg = _('Task __call__() occurred but Task %s is not at WAITING')
            _logger.warning(msg % self.request.id)
        self.state = Task.RUNNING
        self.started_at = timezone.now()
        self.save()

    def set_completed(self, error):
        """
        Set this Task to the completed state, save it, and log output in warning cases.

        This updates the :attr:`finished_at` and sets the :attr:`state` to :attr:`COMPLETED`.

        Args:
            error (dict): Fatal errors to save on the :class:`~pulpcore.app.models.Task`
        """
        self.finished_at = timezone.now()

        # Only set the state to finished if it's not already in a complete state. This is
        # important for when the task has been canceled, so we don't move the task from canceled
        # to finished.
        if self.state not in TASK_FINAL_STATES:
            self.state = Task.COMPLETED
        else:
            msg = _('Task set_completed() occurred but Task %s is already in final state')
            _logger.warning(msg % self.pk)

        self.save()

    def set_failed(self, exc, einfo):
        """
        Set this Task to the failed state and save it.

        This updates the :attr:`finished_at` attribute, sets the :attr:`state` to
        :attr:`FAILED`, and sets the :attr:`error` attribute.

        Args:
            exc (Exception): The exception raised by the task.
            einfo (celery.datastructures.ExceptionInfo): ExceptionInfo instance containing a
                serialized traceback.
        """
        self.state = Task.FAILED
        self.finished_at = timezone.now()
        self.error = exception_to_dict(exc, einfo.traceback)
        self.save()


class TaskTag(Model):
    """
    Custom tags for a task

    Fields:

        name (models.TextField): The name of the tag

    Relations:

        task (models.ForeignKey): The task this tag is associated with
    """
    name = models.TextField()

    task = models.ForeignKey("Task", related_name="tags", related_query_name="tag")
